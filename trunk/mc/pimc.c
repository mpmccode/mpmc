/* 

@2007, Jonathan Belof
Space Research Group
Department of Chemistry
University of South Florida

*/

#include <mc.h>

int pimc(system_t *system) {

	return(0);

}


#ifdef XXX


/********************************************************************************/
/*										*/
/* Path integral Monte Carlo calculation for singular atomic systems		*/
/*										*/
/* This code calculates the path integral for a 1s electron around an external	*/
/* potential generated by Z protons at the cartesian origin.  The calculated	*/
/* observables are the total energy and the coordinates of the Trotter beads.	*/
/*										*/
/* compilation:									*/
/*	gcc -o atomic_pimc atomic_pimc.c -lm					*/
/*										*/
/* usage: ./pimc <Z> <trot> <temp> <move> <scale> <steps> <corr>		*/
/*		<Z>		= atomic number					*/
/*		<trot>		= Trotter number of beads			*/
/*		<temp>		= temperature of the system (K)			*/
/*		<scale>		= scale for the bead move			*/
/*		<steps>		= number of MC steps to perform			*/
/*		<corr>		= sampling interval				*/
/*										*/
/* The pseudo-potential allows the use of ~100 Trotter beads per fermion, but	*/
/* the sampling efficiency could by much better by anticipating the true	*/
/* wavefunction nodes a la Ceperley (Recent Adv. in QM Methods II, 2002) and	*/
/* focusing the sampling there.							*/
/*										*/
/* @2007 Jonathan Belof								*/
/* Space Research Group								*/
/* Department of Chemistry							*/
/* University of South Florida							*/
/********************************************************************************/


/* set the nucleus */

#define	COORDS_OUTPUT_FILENAME		"output.coords"		/* xmov formatted output of coordinates */
#define ENERGY_OUTPUT_FILENAME		"output.energy"		/* energy output for plotting */
#define XMOV_SET_FILENAME		"output.set"		/* for xmov viewing */
#define XMOV_PROTON_TOP_FILENAME	"proton.top"		/* for xmov viewing */
#define XMOV_ELECTRON_TOP_FILENAME	"electron.top"		/* for xmov viewing */

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <math.h>
#include <time.h>

/* conversions */
#define KPSA                    1.202717                                /* number of amu's in 1 KPSA mass unit */
#define H_OVER_K                47.9923862                              /* Planck's constant divided by boltzmann's constant (K ps) */
#define H_OVER_K_SQUARED        2303.26913                              /* above constant, squared */
#define HBAR_OVER_K             7.63822547                              /* Planck's bar divided by boltzmann's constant (K ps) */
#define HBAR_OVER_K_SQUARED     58.3424884                              /* the above constant, squared */
#define BOLTZMANNS_CONSTANT	1.38650e-23				/* Boltzmann's constant */
#define K_TO_EV			8.65385313e-5				/* Conversion factor for K -> eV */

/* physical constants */
#define BOHR_RADIUS		0.529177210818				/* Bohr radius in angstroms */
#define	ELECTRON_CHARGE		408.781604283				/* in reduced units of sqrt(K*A) */
#define ELECTRON_MASS		6.597860309e-4				/* electron mass in KPSA (0.00054857961673 g/mol) */
#define PROTON_MASS		1.211466984				/* proton mass in KPSA (1.007275181 g/mol) */

/* pseudo-potential switching distance */
#define SWITCHING		0.5*BOHR_RADIUS

/* data structure for a quantum particle */
struct particle_t {
	double mass;			/* particle mass */
	int trotter;			/* number of beads in the ring polymer */
	struct bead_t *bead_list;	/* circular linked list of beads */
};

/* data structure for the Trotter beads on the cyclic polymer */
struct bead_t {
	double x, y, z;			/* coordinates */
	struct bead_t *next;		/* ptr to the next bead */
};

/* global copy of the particle state for saving/restoring across functions */
struct particle_t *saved_particle_array;

/* initialize the pseudo RNG */
void seed_random_number(void) {

	srand48(time(NULL));

}

/* returns a double from 0.0 to 1.0 */
double get_random_number() {

	return(drand48());

}

/* takes system parameters as input, returns an array of initialized particles */
struct particle_t *initialize_system(int trotter) {

	int i;
	struct particle_t *particle_array = NULL;	/* particle array pointer */
	struct bead_t *current_bead_ptr;		/* current working bead pointer */
	double random_theta, random_phi;		/* random angles */

	/* allocate the particle array */
	particle_array = calloc(sizeof(struct particle_t), 1);		/* a single particle */
	if(!particle_array) {
		fprintf(stderr, "initialize_system: couldn't allocate particle array\n");
		return(NULL);
	}
	particle_array[0].mass = ELECTRON_MASS;					/* set the particle mass */
	particle_array[0].trotter = trotter;					/* set the trotter number for the ring */

	/* allocate the beads */
	particle_array[0].bead_list = calloc(sizeof(struct bead_t), 1);	/* start with the first one */
	current_bead_ptr = particle_array[0].bead_list;
	if(!current_bead_ptr) {
		fprintf(stderr, "initialize_system: couldn't allocate first bead element\n");
		return(NULL);
	}
	current_bead_ptr->x = BOHR_RADIUS;
	current_bead_ptr->y = 0.0;
	current_bead_ptr->z = 0.0;
	for(i = 0; i < (trotter - 1); i++) {				/* allocate the rest of the beads */
		current_bead_ptr->next = calloc(sizeof(struct bead_t), 1);
		current_bead_ptr = current_bead_ptr->next;
		if(!current_bead_ptr) {
			fprintf(stderr, "initialize_system: couldn't allocate bead number %d\n", (i + 1));
			return(NULL);
		}
		current_bead_ptr->x = BOHR_RADIUS;
		current_bead_ptr->y = 0.0;
		current_bead_ptr->z = 0.0;

	}
	current_bead_ptr->next = particle_array[0].bead_list;		/* connect the circle */
	/* done setting up the particles */

	/* setup the space for saving/restoring the system state */
	saved_particle_array = calloc(sizeof(struct particle_t), 1);
	if(!saved_particle_array) {
		fprintf(stderr, "initialize_system: couldn't allocate saved particle array\n");
		return(NULL);
	}
	saved_particle_array[0].bead_list = calloc(sizeof(struct bead_t), 1);
	current_bead_ptr = saved_particle_array[0].bead_list;
	if(!current_bead_ptr) {
		fprintf(stderr, "initialize_system: couldn't allocate first saved bead element\n");
		return(NULL);
	}
	for(i = 0; i < (trotter - 1); i++) {
		current_bead_ptr->next = calloc(sizeof(struct bead_t), 1);
		current_bead_ptr = current_bead_ptr->next;
		if(!current_bead_ptr) {
			fprintf(stderr, "initialize_system: couldn't allocate bead number %d\n", (i + 1));
			return(NULL);
		}
	}
	current_bead_ptr->next = saved_particle_array[0].bead_list;

	/* seed the RNG */
	seed_random_number();

	return(particle_array);
}

/* calculate the coulombic energy due to the proton at the origin, include a pseudo-potential */
double get_external_potential(struct particle_t *particle_array, double Z, double switching) {

	int i;
	double r, external_energy;
	struct bead_t *cur_ptr;

	cur_ptr = particle_array[0].bead_list;
	for(i = 0, external_energy = 0.0; i < particle_array[0].trotter; i++) {
		r = sqrt(cur_ptr->x*cur_ptr->x + cur_ptr->y*cur_ptr->y + cur_ptr->z*cur_ptr->z);
		if(r < switching)	/* impose the pseudo-potential */
			external_energy += -(Z*ELECTRON_CHARGE*ELECTRON_CHARGE*((r*r/(2.0*switching*switching)) - 3.0/2.0))/switching;
		else
			external_energy += -Z*ELECTRON_CHARGE*ELECTRON_CHARGE/r;
		cur_ptr = cur_ptr->next;
	}
	external_energy /= ((double)particle_array[0].trotter);

	return(external_energy);

}

/* calculate the path integral harmonic energy for the ring polymer */
double get_internal_potential(struct particle_t *particle_array, double temperature) {

	int i;
	struct bead_t *cur_ptr, *nxt_ptr;
	double internal_energy;
	double dx, dy, dz, displacement_squared;

	/* get the ring polymer energy */
	cur_ptr = particle_array[0].bead_list;
	nxt_ptr = cur_ptr->next;
	for(i = 0, internal_energy = 0.0; i < particle_array[0].trotter; i++) {
		dx = cur_ptr->x - nxt_ptr->x;
		dy = cur_ptr->y - nxt_ptr->y;
		dz = cur_ptr->z - nxt_ptr->z;
		displacement_squared = dx*dx + dy*dy + dz*dz;
		internal_energy += displacement_squared;
		cur_ptr = cur_ptr->next;
		nxt_ptr = cur_ptr->next;
	}
	internal_energy *= (((double)particle_array[0].trotter)*particle_array[0].mass*temperature*temperature)/(2.0*HBAR_OVER_K_SQUARED);

	return(internal_energy);

}

/* get the total energy for the system */
double get_energy(struct particle_t *particle_array, double Z, double temperature) {

	double energy;

	energy = get_external_potential(particle_array, Z, SWITCHING);
	energy += get_internal_potential(particle_array, temperature);

	return(energy);
}

/* make a random trial move */
void make_move(struct particle_t *particle_array, double scale) {

	int i;
	struct bead_t *cur_ptr;

	/* move each bead by a random amount */
	cur_ptr = particle_array[0].bead_list;
	for(i = 0; i < particle_array[0].trotter; i++) {

		cur_ptr->x += scale*(0.5 - get_random_number());
		cur_ptr->y += scale*(0.5 - get_random_number());
		cur_ptr->z += scale*(0.5 - get_random_number());

		cur_ptr = cur_ptr->next;
	}


}

/* MC accept routine, stores the accepted coordinates */
void mc_accept(struct particle_t *particle_array) {

	int i;
	struct bead_t *saved_ptr, *current_ptr;


	/* save the accepted configuration */
	saved_particle_array[0].trotter = particle_array[0].trotter;
	saved_particle_array[0].mass = particle_array[0].mass;

	current_ptr = particle_array[0].bead_list;
	saved_ptr = saved_particle_array[0].bead_list;
	for(i = 0; i < particle_array[0].trotter; i++) {
		saved_ptr->x = current_ptr->x;
		saved_ptr->y = current_ptr->y;
		saved_ptr->z = current_ptr->z;
		current_ptr = current_ptr->next;
		saved_ptr = saved_ptr->next;
	}

}

/* MC reject routine, restore the last accepted coordinates */
void mc_reject(struct particle_t *particle_array) {

	int i;
	struct bead_t *saved_ptr, *current_ptr;

	/* restore the last accepted configuration */
	particle_array[0].trotter = saved_particle_array[0].trotter;
	particle_array[0].mass = saved_particle_array[0].mass;

	current_ptr = particle_array[0].bead_list;
	saved_ptr = saved_particle_array[0].bead_list;
	for(i = 0; i < saved_particle_array[0].trotter; i++) {
		current_ptr->x = saved_ptr->x;
		current_ptr->y = saved_ptr->y;
		current_ptr->z = saved_ptr->z;
		current_ptr = current_ptr->next;
		saved_ptr = saved_ptr->next;
	}

}

/* write the system coordinates to a file */
void write_coords(struct particle_t *particle_array, FILE *fp_coords) {

	int i;
	struct bead_t *cur_ptr;

	/* print the proton coords */
	fprintf(fp_coords, "0.0 0.0 0.0\n");

	/* print the electron's beads */
	cur_ptr = particle_array[0].bead_list;
	for(i = 0; i < particle_array[0].trotter; i++) {
		fprintf(fp_coords, "%lg %lg %lg\n", cur_ptr->x, cur_ptr->y, cur_ptr->z);	/* output coords */
		cur_ptr = cur_ptr->next;
	}
	/* print artificial periodic boundary */
	fprintf(fp_coords, "%lg 0.0 0.0 0.0 %lg 0.0 0.0 0.0 %lg\n", 4*BOHR_RADIUS, 4*BOHR_RADIUS, 4*BOHR_RADIUS);

}

/* write the system energy to a file */
void write_energy(double energy, FILE *fp_energy) {

	fprintf(fp_energy, "%lg\n", energy);
}


/* perform the path integral monte carlo calculation - the meat 'n potatos */
int do_pimc(struct particle_t *particle_array, double Z, double temperature, double scale, int num_steps, int corr_time) {

	int i, j;						/* MC step counter */
	double initial_energy;					/* energy before making MC move */
	double final_energy;					/* energy after making MC move */
	double delta_energy;					/* energy change due to the MC move */
	double boltzmann;					/* boltzmann factor */
	double accepted_energy;					/* accepted energy to be averaged */
	double accepted_energy_squared;				/* accepted energy squared */
	double radius;						/* bead radius from the proton */
	double accepted_radius;					/* accepted value for averaging */
	double average_radius;					/* simulation average radius */
	double average_energy = 0;				/* average accepted energy */
	double average_energy_squared = 0;			/* average square of the accepted energy */
	double average_boltzmann = 0;				/* average boltzmann factor */
	double average_factor = 0;				/* numerical factor used for the running averages */
	int accepts = 0, rejects = 0;				/* keep track of acceptance rate */
	FILE *fp_coords, *fp_energy;				/* file pointers for output */
	FILE *fp_set, *fp_proton_top, *fp_electron_top;		/* used for xmov movie output */
	struct bead_t *cur_ptr;					/* used for radius calculation */

	if(!particle_array || (num_steps <= 0)) {
		fprintf(stderr, "do_pimc: invalid input parameters passed\n");
		return(-1);
	}

	/* set the temperature */
	if(temperature < 0.0) {
		fprintf(stderr, "do_pimc: invalid temperature specified\n");
		return(-1);
	}

	/* open the output files for writing */
	fp_coords = fopen(COORDS_OUTPUT_FILENAME, "w");
	filecheck(fp_coords,COORDS_OUTPUT_FILENAME,WRITE);
	fp_energy = fopen(ENERGY_OUTPUT_FILENAME, "w");
	filecheck(fp_energy,ENERGY_OUTPUT_FILENAME,WRITE);

	/* write xmov header to coords file */
	fprintf(fp_coords, "# %d 1 0.001\n", (particle_array[0].trotter + 1));
	/* output the xmov set and top files */
	fp_set = fopen(XMOV_SET_FILENAME, "w");
	fprintf(fp_set, "~mol_def[\\mol_parm_file{proton.top}\\mol_therm_opt{none}\\nmol{1}\\mol_index{1}]\n");
	fprintf(fp_set, "~mol_def[\\mol_parm_file{electron.top}\\mol_therm_opt{none}\\nmol{%d}\\mol_index{2}]\n", particle_array[0].trotter);
	fp_proton_top = fopen(XMOV_PROTON_TOP_FILENAME, "w");
	fprintf(fp_proton_top, "~mol_name_def[\\mol_name{proton}\\natom{1}\\nbond{0}\\nbondx{0}]\n");
	fprintf(fp_proton_top, "~atom_def[\\atom_typ{P}\\atom_ind{1}\\mass{1.0}\\charge{0.0}\\alpha{0.000}]\n");
	fp_electron_top = fopen(XMOV_ELECTRON_TOP_FILENAME, "w");
	fprintf(fp_electron_top, "~mol_name_def[\\mol_name{electron}\\natom{1}\\nbond{0}\\nbondx{0}]\n");
	fprintf(fp_electron_top, "~atom_def[\\atom_typ{E}\\atom_ind{1}\\mass{0.0001}\\charge{0.0}\\alpha{0.000}]\n");
	fclose(fp_set); fclose(fp_proton_top); fclose(fp_electron_top);

	/* get the first energy and automatically accept it */
	initial_energy = get_energy(particle_array, Z, temperature);
	mc_accept(particle_array);
	accepted_energy = get_external_potential(particle_array, Z, SWITCHING);
	accepted_energy_squared = accepted_energy*accepted_energy;

	/* get the initial radius */
	cur_ptr = particle_array[0].bead_list;
	for(j = 0, accepted_radius = 0.0; j < particle_array[0].trotter; j++) {
		radius = sqrt(cur_ptr->x*cur_ptr->x + cur_ptr->y*cur_ptr->y + cur_ptr->z*cur_ptr->z);
		accepted_radius += radius;
		cur_ptr = cur_ptr->next;
	}
	accepted_radius /= ((double)particle_array[0].trotter);

	/* this is the main loop */
	for(i = 0; i < num_steps; i++) {

		/* make a trial move */
		make_move(particle_array, scale);

		/* get the post-move energy, energy change and boltzmann factor */
		final_energy = get_energy(particle_array, Z, temperature);
		delta_energy = final_energy - initial_energy;
		boltzmann = exp(-delta_energy/temperature);

		/* perform the metropolis evaluation */
		if(get_random_number() < boltzmann) {	/****** ACCEPT ******/

			mc_accept(particle_array);
			++accepts;
			initial_energy = final_energy;	/* save for the next MC step */
			accepted_energy = get_external_potential(particle_array, Z, SWITCHING);
			accepted_energy_squared = accepted_energy*accepted_energy;

			/* get the average bead radius */
			cur_ptr = particle_array[0].bead_list;
			for(j = 0, accepted_radius = 0.0; j < particle_array[0].trotter; j++) {
				radius = sqrt(cur_ptr->x*cur_ptr->x + cur_ptr->y*cur_ptr->y + cur_ptr->z*cur_ptr->z);
				accepted_radius += radius;
				cur_ptr = cur_ptr->next;
			}
			accepted_radius /= ((double)particle_array[0].trotter);


		} else {	/****** REJECT ******/

			mc_reject(particle_array);
			++rejects;
		}

		if(!(i % corr_time)) {
			/* write out the coordinates */
			write_coords(particle_array, fp_coords);
			/* write out the total energy */
			write_energy(accepted_energy*K_TO_EV, fp_energy);
		}

		/* keep a running average of the energy */
		average_factor = ((double)i)/((double)(i + 1));
		average_energy = average_energy*average_factor + (accepted_energy / ((double)(i + 1)));
		average_energy_squared = average_energy_squared*average_factor + (accepted_energy_squared / ((double)(i + 1)));
		average_boltzmann = average_boltzmann*average_factor + (boltzmann / ((double)(i + 1)));
		average_radius = average_radius*average_factor + (accepted_radius / ((double)(i + 1)));

	}

	/* output useful stats to stdout */
	printf("\n\n*********************************************************\n");
	printf("********** temperature = %.2f (K)\n", temperature);
	printf("********** acceptance rate = %.3f\n", ((double)accepts)/((double)i));
	printf("********** average boltzmann factor = %.5f\n", average_boltzmann);
	printf("********** average energy = %.3f (eV)\n", average_energy*K_TO_EV);
	printf("********** average electron radius = %.3f (A)\n", average_radius);
	printf("********** energy sigma = %.3f (eV)\n", K_TO_EV*sqrt(average_energy_squared - average_energy*average_energy));
	printf("*********************************************************\n\n");

	/* gracefully close our file pointer streams */
	fclose(fp_coords);
	fclose(fp_energy);

	return(0);

}

/* cleans up the particle array */
void free_particle(struct particle_t *particle_array) {

	int i;
	struct bead_t *current_bead_ptr, **free_array;

	free_array = calloc(sizeof(struct bead_t *), particle_array[0].trotter);
	memnullcheck(free_array,sizeof(struct bead_t *)*particle_array[0].trotter,53);
	current_bead_ptr = particle_array[0].bead_list;

	for(i = 0; i < particle_array[0].trotter; i++) {
		free_array[i] = current_bead_ptr;
		current_bead_ptr = current_bead_ptr->next;
	}

	for(i = 0; i < particle_array[0].trotter; i++)
		free(free_array[i]);

	free(particle_array);
	free(free_array);

}

/* provide usage information for the user */
void usage(char *progname) {

	fprintf(stderr, "usage: %s <Z> <trot> <temp> <scale> <steps> <corr>\n", progname);
	fprintf(stderr, "\t<Z>\t\t\t = atomic number\n");
	fprintf(stderr, "\t<trot>\t\t\t = Trotter number of beads\n");
	fprintf(stderr, "\t<temp>\t\t\t = temperature of the system (K)\n");
	fprintf(stderr, "\t<scale>\t\t\t = bead move scaling parameter\n");
	fprintf(stderr, "\t<steps>\t\t\t = number of MC steps to perform\n");
	fprintf(stderr, "\t<corr>\t\t\t = interval of configuration sampling\n\n");
	exit(1);
}

int main(int argc, char **argv) {

	int i;					/* counter */
	int num_steps, corr_time;		/* number of MC steps to do and correlation time */
	int trotter;				/* Trotter number of beads */
	double temperature;			/* temperature of the system (K) */
	double scale;				/* amount to scale the bead moves by */
	struct particle_t *particle_array;	/* particle array, currently just a single particle */
	double Z;				/* atomic number */

	/* read cmd line args */
	if(argc != 7)
		usage(argv[0]);

	printf("%s: input invokation = ", argv[0]);
	for(i = 0; i < argc; i++)
		printf("%s ", argv[i]);
	putchar('\n');

	/* get the atomic number */
	Z = atof(argv[1]);
	if(Z < 0) {
		fprintf(stderr, "%s: ERROR: invalid Z specified\n", argv[0]);
		usage(argv[0]);
	}

	/* get the Trotter number */
	trotter = atoi(argv[2]);
	if(trotter < 0) {
		fprintf(stderr, "%s: ERROR: invalid Trotter number specified\n", argv[0]);
		usage(argv[0]);
	}

	/* get the temperature */
	temperature = atof(argv[3]);
	if(temperature < 0.0) {
		fprintf(stderr, "%s: ERROR: invalid temperature specified\n", argv[0]);
		usage(argv[0]);
	}

	/* get the amount to scale the beads by */
	scale = atof(argv[4]);
	if(scale <= 0.0) {
		fprintf(stderr, "%s: ERROR: invalid bead scaling specified\n", argv[0]);
		exit(1);
	}

	/* get the number of MC steps to perform */
	num_steps = atoi(argv[5]);
	if(num_steps <= 0) {
		fprintf(stderr, "%s: ERROR: invalid number of MC steps specified\n", argv[0]);
		exit(1);
	}

	/* get the correlation interval for sampling */
	corr_time = atoi(argv[6]);
	if(corr_time <= 0) {
		fprintf(stderr, "%s: ERROR: invalid correlation time specified\n", argv[0]);
		exit(1);
	}

	particle_array = initialize_system(trotter);
	if(!particle_array) {
		fprintf(stderr, "%s: ERROR: couldn't initialize the system\n", argv[0]);
		exit(1);
	}

	/* start the path integral monte carlo */
	if(do_pimc(particle_array, Z, temperature, scale, num_steps, corr_time) < 0) {
		fprintf(stderr, "%s: ERROR: path integral MC loop died\n", argv[0]);
		exit(1);
	}

	free_particle(particle_array);
	exit(0);

}

#endif /* XXX */

